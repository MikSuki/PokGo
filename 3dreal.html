<html>

<head>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js'></script>
    <script src="js/lib/GLTFLoader.js"></script>
</head>

<body>
    <script>
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        var renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);


        camera.position.z = 5;


        v0_x = 0; //initial velocity
        v0_y = 4;
        v0_z = 1;
        w_x = 0 * Math.PI; // initial angular velocity
        w_y = 2 * Math.PI;
        w_z = 0 * Math.PI;
        m = 1; //weight
        rho = 1.2; // air density
        g = 9.8; // gravity 
        f = 10; //frequency of the rotation of the pokeball
        cl = 1.23; //horizontal tension coefficient
        cd = 0.5; //air resistance coefficient
        D = 0.22; // diameter of the pokeball
        A = Math.PI * Math.pow((0.5 * D), 2); //cross-sectional area of the pokeball
        t_step = 1 / 60;
        b = (1 / 2) * cd * rho * A; //for convenience
        c = cl * rho * Math.pow(D, 3) * f; // for convenience
        vt_x = v0_x
        vt_y = v0_y
        vt_z = v0_z

        animateKick = function () {
            if (pokeball.position.y < 0) {
                return;
            }
            tmp_1 = c * Math.pow(Math.pow(vt_x, 2) + Math.pow(vt_z, 2) + Math.pow(vt_y, 2), 2)

            tmp_2 = (Math.sqrt(Math.pow(w_z * vt_y - w_y * vt_z, 2) + Math.pow(w_y * vt_x - w_x * vt_y, 2) + Math.pow(w_x * vt_z - w_z * vt_x, 2)))

            tmp = tmp_1 / tmp_2

            Fl_x = tmp * (w_z * vt_y - w_y * vt_z)

            Fl_z = tmp * (w_y * vt_x - w_x * vt_y)

            Fl_y = tmp * (w_x * vt_z - w_z * vt_y)

            //Motion differential equation
            a_x = -(b / m) * Math.sqrt((Math.pow(vt_z, 2) + Math.pow(vt_y, 2) + Math.pow(vt_x, 2))) * vt_x + (Fl_x / m)
            a_z = -(b / m) * Math.sqrt((Math.pow(vt_z, 2) + Math.pow(vt_y, 2) + Math.pow(vt_x, 2))) * vt_z + (Fl_z / m)
            a_y = -g - (b / m) * Math.sqrt((Math.pow(vt_z, 2) + Math.pow(vt_y, 2) + Math.pow(vt_x, 2))) * vt_y + (Fl_y / m)

            //use formula : s_t = s_0 + v_0 * t to update the position
            pokeball.position.x = pokeball.position.x + vt_x * t_step
            pokeball.position.z = pokeball.position.z + vt_z * t_step
            pokeball.position.y = pokeball.position.y + vt_y * t_step

            //use formula : v_t = a * t to update the velocity 
            vt_x = vt_x + a_x * t_step
            vt_z = vt_z + a_z * t_step
            vt_y = vt_y + a_y * t_step

        }


        var loader = new THREE.GLTFLoader();
        var pokeball;

        loader.load('3d/pokeball.glb', function (gltf) {
            pokeball = gltf.scene;
            // pokeball.scale.set(5, 5, 5);
            //  pokeball.scale.set(.05, .05, .05);
            // selectedModel.position.y = 45;
            scene.add(pokeball);
            animate();

        }, undefined, function (error) {
            console.error(error);
        });

        var hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight.position.set(0, 0, 0);
        scene.add(hemiLight);

        function animate() {
            animateKick()
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>